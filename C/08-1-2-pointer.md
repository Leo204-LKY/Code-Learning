# 指针  

scanf() 中，  
如果能够将取得的变量的地址传递给一个函数，能否通过这个地址在那个函数内访问这个变量？  
```C
scanf("%d", &i);  
```
scanf() 的原型应该是什么样的？我们需要一个参数能保存别的变量的地址，如何表达能够保存地址的变量？  

## 指针就是保存地址的变量  
```C
int i;
int* p = &i;
int* p, q;
int *p, q;
```
- 这里的星号 `*` 就表示这个变量是一个指针，通常使用指针的英文 `pointer` 的第一个字母 `p` 作为变量名  
- 前两行中，假设变量 `i` 存储在 `0x2000` 位置，那么变量 `p` 的值就是 `2000`  
    - 这里就有一个说法： `p` 指向了 `i`  
- 后两行中有一个小细节需要注意  
    - 星号 `*` 可以靠近 int ，也可以远离 int 靠近变量  
    - 但这两行的意思都是一样的：`p` 是一个指针，而 `q` 只是普通的变量  
    - 因此，并不是把星号 `*` 加给了 int ，而是加给了变量 `p`  
    - 要表达 q 也是个指针，应该这样写：  
        ```C
        int *p, *q;
        ```

### 指针变量  
- 变量的值是内存的地址  
    - 普通变量的值是实际的值  
    - 指针变量的值是具有实际值的变量的地址  

### 作为参数的指针  
- `void f(int *p)`  
- 在被调用的时候得到了某个变量的地址  
    - `int i = 0; f(&i);  
- 在函数里面可以通过这个指针访问外面的这个 i  

示例：  
```C
#include <stdio.h>

void f(int *p);

int main(void)
{
    int i = 6;
    printf("&i = %p\n", &i);
    f(&i);
    return 0;
}

void f(int *p)
{
    printf("p = %p\n", p);
}
```
以上方法无论是在主函数还是 `f` 函数中，获取到的地址是一样的  
如果不使用指针直接传入变量，传入后的变量与外部的变量没有任何关系  
我们虽然不知道这个变量叫做 `i` ，但我们可以知道它的地址，使得 `f` 函数拥有了能访问和修改外部这个变量 `i` 的能力  

### 访问那个地址上的变量：`*`
- `*` 是一个单目运算符，用来访问指针的值所表示的地址上的变量  
- 可以做右值也可以做左值（既可以在等号右边也可以在等号左边）  
    - `int k = *p;`  
    - `p = k + 1;`  

在上面的代码中，我们已经在函数 `f` 中得到了外部变量的地址  
继续扩充：  
```C
void f(int *p)  // *p 是一个整体，可以看作一个整数
{
    printf(" p = %p\n", p);
    printf("*p = %d\n", *p);
    *p = 26
}
```
- 第二个 printf() 即可获取到原先变量 `i` 的值 `6`  
- `*p = 26` 则可以将 `i` 的值改为了 `26`

### 传入地址  
- 为什么  
    ```C
    int i;
    scanf("%d", i);
    ```
    编译不会报错？  
- C 语言将传入的变量 `i` 看作一个地址，因此编译时不会报错  
- 但实际运行时会报错，因为 C 语言将这个值写到了不该写的地方  